<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SecondPlayer&#39;s Blog</title>
  <subtitle>我读书多，你别骗我</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.secondplayer.top/"/>
  <updated>2017-09-07T16:09:51.518Z</updated>
  <id>http://www.secondplayer.top/</id>
  
  <author>
    <name>secondplayer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见推荐系统介绍</title>
    <link href="http://www.secondplayer.top/2017/09/08/recommendation-system-book/"/>
    <id>http://www.secondplayer.top/2017/09/08/recommendation-system-book/</id>
    <published>2017-09-07T16:07:37.000Z</published>
    <updated>2017-09-07T16:09:51.518Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对项亮的<a href="https://book.douban.com/subject/10769749/" target="_blank" rel="external">推荐系统实践</a>部分章节进行了一些总结，先从什么是推荐系统开始讲起，然后介绍了评测推荐系统的指标和方法，最后介绍了常见的推荐系统算法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2245716-7457fe3c0981d437.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《推荐系统实践》封面"></p>
<h2 id="什么是推荐系统"><a href="#什么是推荐系统" class="headerlink" title="什么是推荐系统"></a>什么是推荐系统</h2><p>随着信息技术和互联网的快速发展，人们逐渐从信息匮乏的时代走入了信息过载的时代。每天都有海量的信息被生产出来，用户如何从中找到自己感兴趣的内容变得越来越困难，内容生产者也在想方设法让自己生成的内容从海量信息中脱颖而出。为了解决信息过载的问题，历史上出现过的代表方案有分类目录和搜索引擎，这两者都要求用户明确知道自己需要的内容关键词。而推荐系统不需要用户提供明确的需求，而是通过分析用户的历史行为给用户的兴趣建模，从而主动给用户推荐能够满足它们兴趣的内容。推荐系统通过发掘用户的行为，找到用户的个性化需求，从而将<a href="https://zh.wikipedia.org/wiki/%E9%95%BF%E5%B0%BE" target="_blank" rel="external">长尾</a>商品准确地推荐给需要它的用户，帮助用户发现那些他们感兴趣但很难发现的商品。</p>
<h2 id="推荐系统的应用"><a href="#推荐系统的应用" class="headerlink" title="推荐系统的应用"></a>推荐系统的应用</h2><p>在互联网的各类网站中都可以看到推荐系统的应用，尽管不同网站使用的技术不同，但总的来说几乎所有的推荐系统应用都是由前台的展示页面、后台的日志系统以及推荐算法系统构成。</p>
<ul>
<li>电子商务：<a href="https://www.taobao.com/" target="_blank" rel="external">淘宝</a>、<a href="https://www.jd.com/" target="_blank" rel="external">京东</a>、<a href="https://www.amazon.com/" target="_blank" rel="external">亚马逊</a></li>
<li>电影/视频：<a href="https://www.netflix.com/" target="_blank" rel="external">Netflix</a>、<a href="https://www.youtube.com/" target="_blank" rel="external">YouTube</a>、<a href="http://www.iqiyi.com/" target="_blank" rel="external">爱奇艺</a></li>
<li>音乐：<a href="http://www.pandora.com/" target="_blank" rel="external">Pandora</a>、<a href="http://music.163.com/" target="_blank" rel="external">网易云音乐</a>、<a href="https://douban.fm/" target="_blank" rel="external">豆瓣FM</a></li>
<li>社交网络：<a href="https://www.facebook.com/" target="_blank" rel="external">Facebook</a>、<a href="https://twitter.com/" target="_blank" rel="external">Twitter</a>、<a href="http://www.linkedin.com/" target="_blank" rel="external">LinkedIn</a>、<a href="http://weibo.com/" target="_blank" rel="external">新浪微博</a></li>
<li>个性化阅读：<a href="http://digg.com/" target="_blank" rel="external">Digg</a>、<a href="https://flipboard.com/" target="_blank" rel="external">Flipboard</a>、<a href="http://www.toutiao.com/" target="_blank" rel="external">今日头条</a></li>
<li>基于位置的服务：<a href="https://foursquare.com/" target="_blank" rel="external">Foursquare</a></li>
<li>个性化广告：<a href="https://developers.facebook.com/docs/audience-network/" target="_blank" rel="external">Facebook Audience Network</a></li>
</ul>
<h2 id="推荐系统实验方法"><a href="#推荐系统实验方法" class="headerlink" title="推荐系统实验方法"></a>推荐系统实验方法</h2><p>在推荐系统中，主要有三种评测推荐效果的实验方法：离线实验、用户调查、在线实验。</p>
<h2 id="推荐系统评测指标"><a href="#推荐系统评测指标" class="headerlink" title="推荐系统评测指标"></a>推荐系统评测指标</h2><ul>
<li>用户满意度：用户的主观感受，主要通过用户调查的方式获得，也可以间接从用户行为统计中得到。</li>
<li>预测准确度：度量一个推荐系统或推荐算法预测用户行为的能力。评分预测的预测准确度一般通过计算测试集和训练集的均方根误差(RMSE)和平均绝对误差(MAE)得到。TopN推荐的预测准确度一般通过计算测试集和训练集的准确率(precison)和召回率(recall)得到。</li>
</ul>
<blockquote>
<p>令r<sub>ui</sub>是用户u对物品i的实际评分，r<sup>^</sup><sub>ui</sub>是推荐算法给出的预测评分，T是测试集，那么：<br>RMSE = sqrt(Σ<sub>u,i∈T</sub>(r<sub>ui</sub>-r<sup>^</sup><sub>ui</sub>)<sup>2</sup> / |T|)<br>MAE = Σ<sub>u,i∈T</sub>|r<sub>ui</sub>-r<sup>^</sup><sub>ui</sub>| / |T|</p>
<p>令R(u)是用户u在训练集上的推荐结果，T(u)是用户u在测试集上的行为结果，U是用户集合，那么：<br> Precision = Σ<sub>u∈U</sub>|R(u) ∩ T(u)| / Σ<sub>u∈U</sub>|R(u)|<br> Recall = Σ<sub>u∈U</sub>|R(u) ∩ T(u)| / Σ<sub>u∈U</sub>|T(u)|</p>
</blockquote>
<ul>
<li>覆盖率：描述一个推荐系统对物品长尾的发掘能力。</li>
</ul>
<blockquote>
<p>假设用户集合为U，物品集合为I，推荐系统给每个用户推荐一个长度为N的物品列表R(u)，那么：<br>Coverage = |∪<sub>u∈U</sub>R(u)| / |I|</p>
</blockquote>
<ul>
<li>多样性：为了满足用户广泛的兴趣，推荐列表需要能够覆盖用户不同的兴趣领域。</li>
<li>新颖性：是指给用户推荐那些他们以前没听说过的商品。</li>
<li>惊喜度(serendipity)：如果推荐结果和用户的历史兴趣不相似，但却让用户觉得满意，那么就可以说推荐结果的惊喜度很高。</li>
<li>信任度：提高信任度的方法是给出合理的推荐解释。</li>
<li>实时性：推荐系统需要实时地更新推荐列表来满足用户新的行为变化，并且需要能够将新加入系统的物品推荐给用户。</li>
<li>健壮性(robust)：衡量一个推荐系统抗击作弊的能力。</li>
</ul>
<p>在众多指标中，作者认为：对于可以离线优化的指标，应该在给定覆盖率、多样性、新颖性等限制条件下，尽量优化预测准确度。</p>
<h2 id="常见推荐系统算法"><a href="#常见推荐系统算法" class="headerlink" title="常见推荐系统算法"></a>常见推荐系统算法</h2><p>推荐系统是联系用户和物品的媒介，而推荐联系用户和物品的方式主要有3种，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2245716-b37cbd23e2424475.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3种联系用户和物品的推荐系统"></p>
<p>第一种方法，首先找到用户喜欢的物品，然后找到与这些物品相似的物品推荐给用户。基于这种方法可以给出如下的推荐解释：购买了该商品的用户也经常购买这些商品。这种方法通常被称为基于物品的协同过滤算法(item-based collaborative filtering)。<br>第二种方法，首先找到和用户有相似兴趣的其他用户，然后推荐这些其他用户喜欢的物品。这种方法通常被称为基于用户的协同过滤算法(user-based collaborative filtering)。<br>第三种方法，首先找到用户感兴趣的物品特征，然后推荐包含这些特征的物品。这种方法核心思想是通过隐含特征联系用户兴趣和物品，通常被称为隐语义模型算法(latent factor model)。</p>
<h2 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h2><p>个性化推荐系统的一个重要算法是基于用户行为分析，学术界一般将这种类型的算法称为协同过滤算法(collaborative filtering)。</p>
<blockquote>
<p>顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。</p>
</blockquote>
<h2 id="基于物品的协同过滤算法"><a href="#基于物品的协同过滤算法" class="headerlink" title="基于物品的协同过滤算法"></a>基于物品的协同过滤算法</h2><p>基于物品的协同过滤算法(以下简称ItemCF)，是目前业界应用最多的算法，最早由电子商务公司亚马逊提出。ItemCF算法给用户推荐那些和他们之前喜欢的物品相似的物品，它的主要步骤分为两步。</p>
<blockquote>
<p>(1) 计算物品之间的相似度<br>   (2) 根据物品的相似度和用户的历史行为给用户生成推荐列表</p>
</blockquote>
<p>第一步计算相似度可用余弦相似度公式</p>
<blockquote>
<p>令N(i)是喜欢物品i的用户集合，那么物品i和物品j的相似度可定义为：<br>   w<sub>ij</sub> = |N(i) ∩ N(j)| / sqrt(|N(i)||N(j)|)</p>
</blockquote>
<p>第二步计算用户对物品的兴趣，如下公式的含义是：和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。</p>
<blockquote>
<p>令p<sub>uj</sub>为用户u对物品j的兴趣，w<sub>ji</sub>是物品j和物品i的相似度，r<sub>ui</sub>是用户u对物品i的兴趣（对于隐反馈数据集，如果用户u对物品i有过行为，可简单令r<sub>ui</sub>=1），S(j,K)是和物品j最相似的K个物品的集合，那么：<br>   p<sub>uj</sub> = Σ<sub>i∈N(u)∩S(j,K)</sub> w<sub>ji</sub>r<sub>ui</sub></p>
</blockquote>
<p>最后选取该用户兴趣值最高的N的物品作为推荐列表。</p>
<h2 id="基于用户的协同过滤算法"><a href="#基于用户的协同过滤算法" class="headerlink" title="基于用户的协同过滤算法"></a>基于用户的协同过滤算法</h2><p>基于用户的协同过滤算法(以下简称UserCF)，是推荐系统中最古老的算法。UserCF算法先找到和他有相似兴趣的其他用户，然后把那些用户喜欢的、而他没有听说过的物品推荐给他，它的主要步骤分为两步。</p>
<blockquote>
<p>(1) 找到和目标用户兴趣相似的用户集合<br>   (2) 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户</p>
</blockquote>
<p>第一步计算用户的兴趣相似度可用余弦相似度公式</p>
<blockquote>
<p>令N(u)是用户u曾经有过正反馈的物品集合，那么用户u和用户v的相似度可定义为：<br>   w<sub>uv</sub> = |N(u) ∩ N(v)| / sqrt(|N(u)||N(v)|)</p>
</blockquote>
<p>第二步计算用户对物品的兴趣</p>
<blockquote>
<p>令p<sub>ui</sub>为用户u对物品i的兴趣，w<sub>uv</sub>是用户u和用户v的相似度，r<sub>vi</sub>是用户v对物品i的兴趣（对于隐反馈数据集，如果用户v对物品i有过行为，可简单令r<sub>vi</sub>=1），S(u,K)是和用户u兴趣最相似的K个用户的集合，那么：<br>   p<sub>ui</sub> = Σ<sub>v∈N(i)∩S(u,K)</sub> w<sub>uv</sub>r<sub>vi</sub></p>
</blockquote>
<p>最后选取该用户兴趣值最高的N的物品作为推荐列表。</p>
<h2 id="隐语义模型"><a href="#隐语义模型" class="headerlink" title="隐语义模型"></a>隐语义模型</h2><p>隐语义模型算法(以下简称LFM)，是最近几年推荐系统领域最为热门的研究话题。LFM算法的核心思想是通过隐含特征联系用户兴趣和物品，它的主要步骤分为三步。</p>
<blockquote>
<p>(1) 对物品进行分类<br>   (2) 确定用户对哪些类的物品感兴趣以及感兴趣的程度<br>   (3) 对于给定的类，确定物品在这个类的权重，并且选择性地推荐给用户</p>
</blockquote>
<p>关于如何给物品分类，一个简单方案是由编辑来手动分类，但这样存在很强的主观性和较大的工作量。为了解决这个困难，研究人员提出可以从用户数据出发，基于隐含语义分析技术(latent variable analysis)自动找到哪些类，然后进行个性化推荐。隐含语义分析技术有很多著名的模型和方法，比如pLSA、LDA、隐含类别模型、隐含主题模型、矩阵分解等。</p>
<blockquote>
<p>LFM通过如下公式计算用户u对物品i的兴趣：<br>   Preference<sub>ui</sub> =  Σ<sub>k∈[1,K]</sub> p<sub>u,k</sub>q<sub>i,k</sub><br>   其中p<sub>u,k</sub>度量了用户u的兴趣和第k个隐类的关系，而q<sub>i,k</sub>度量了第k个隐类和物品i的关系。这两个参数的计算需要一点最优化理论或者机器学习的知识，这里不多作介绍。</p>
</blockquote>
<h2 id="三种算法的优缺点比较"><a href="#三种算法的优缺点比较" class="headerlink" title="三种算法的优缺点比较"></a>三种算法的优缺点比较</h2><ul>
<li>LFM是一种基于机器学习的算法，有较好的理论基础。ItemCF/UserCF是基于邻域的方法，更多的是一种基于统计的方法，没有学习过程。</li>
<li>假设有M个用户和N个物品，选取F个隐类。UserCF需要存储用户的相似度矩阵，存储空间是O(M*M)。ItemCF需要存储物品的相似度矩阵，存储空间是O(N*N)。LFM需要的存储空间是O(F*(M+N))。如果用户数很多，UserCF将会占据很大的内存。如果物品数很多，ItemCF将会占据很大的内存。LFM存储空间最少，这在M和N很大时可以很好地节省离线计算的内存。</li>
<li>假设有M个用户和N个物品和K条用户对物品的行为记录。那么，UserCF计算用户表的时间复杂度是O(N*(K/N)<sup>2</sup>)，而ItemCF计算物品表的时间复杂度是O(M*(K/M)<sup>2</sup>)。而对于LFM，如果用F个隐类，迭代S次，那么它的时间复杂度是O(K*F*S)。在一般情况下，LFM的时间复杂度要稍微高于UserCF和ItemCF，主要是因为该算法需要多次迭代。</li>
<li>ItemCF算法支持很好的推荐解释，它可以利用用户的历史行为解释推荐结果，但LFM无法提供这样的解释。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在互联网应用中可以看到大量推荐系统的应用，它主要解决了信息过载的问题，通过算法主动帮助用户找到自己感兴趣的内容。常见的推荐系统算法有三种，分别代表三种联系用户和物品的方式，它们是：基于物品的协同过滤算法(ItemCF)，基于用户的协同过滤算法(ItemCF)，隐语义模型算法(LFM)。三种方法各有优劣，需要根据实际场景选择合适的算法，通过不断优化指标找到最优算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是对项亮的&lt;a href=&quot;https://book.douban.com/subject/10769749/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;推荐系统实践&lt;/a&gt;部分章节进行了一些总结，先从什么是推荐系统开始讲起，然后介绍了评测推荐
    
    </summary>
    
    
      <category term="推荐系统" scheme="http://www.secondplayer.top/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="读书笔记" scheme="http://www.secondplayer.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用redis的有序集合实现排行榜功能</title>
    <link href="http://www.secondplayer.top/2017/07/23/redis-sorted-set/"/>
    <id>http://www.secondplayer.top/2017/07/23/redis-sorted-set/</id>
    <published>2017-07-23T05:43:36.000Z</published>
    <updated>2017-09-04T15:34:43.987Z</updated>
    
    <content type="html"><![CDATA[<p>排行榜是业务开发中常见的一个场景，如何设计一个好的数据结构能够满足高效实时的查询，下面我们结合一个实际例子来讨论一下。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>选手报名参加活动，观众可以对选手进行投票，每个观众对同一名选手只能投一票，活动期间最多投四票。后台需要提供如下接口：</p>
<ul>
<li>接口1：返回TOP 10的选手信息及投票数</li>
<li>接口2：返回活动总参与选手数及总投票数</li>
<li>接口3：对于每个选手，返回自己的投票数，排名，距离上一名差的票数</li>
</ul>
<h2 id="基于数据库的方案"><a href="#基于数据库的方案" class="headerlink" title="基于数据库的方案"></a>基于数据库的方案</h2><p>首先需要一张表存储投票记录，一次投票就是一条记录。这张表相当于投票明细，判断每人只投一张票以及最多投四张表都依赖对这张表的查询。<br>如果直接对这张表做TOP 10的查询，则需要根据选手id做聚合查询，这样每次查询必然耗时。为了优化查询，可以增加另一张排行榜表，用一个定时任务每隔一段时间对原表做聚合查询，然后将结果写进排行榜表里，表里包含投票数及排名的字段，这样查询TOP 10和排名的时候直接查这张表。引入另一张表加快了性能，但牺牲了实时性，活动说明里需加上类似“榜单数据每10分钟同步一次”的话来告知用户。</p>
<h2 id="基于redis的方案"><a href="#基于redis的方案" class="headerlink" title="基于redis的方案"></a>基于redis的方案</h2><p>对于排行榜的需求，redis有一个数据结构非常适合做这件事，那就是有序集合(sorted set)。</p>
<h3 id="redis的有序集合相关命令"><a href="#redis的有序集合相关命令" class="headerlink" title="redis的有序集合相关命令"></a>redis的有序集合相关命令</h3><p>有序集合和集合一样可以存储字符串，另外有序集合的成员可以关联一个分数(score)，这个分数用于集合排序。下面以投票为例说明常见的命令，vote_activity是有序集合的key。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#给Alice投票</div><div class="line">redis&gt; zincrby vote_activity 1 Alice</div><div class="line">&quot;1&quot; </div><div class="line">#给Bob投票</div><div class="line">redis&gt; zincrby vote_activity 1 Bob</div><div class="line">&quot;1&quot;</div><div class="line">#给Alice投票</div><div class="line">redis&gt; zincrby vote_activity 1 Alice</div><div class="line">&quot;2&quot;</div><div class="line">#查看Alice投票数</div><div class="line">redis&gt; zscore vote_activity Alice</div><div class="line">&quot;2&quot;</div><div class="line">#获取Alice排名(从高到低，zero-based)</div><div class="line">redis&gt; zrevrank vote_activity Alice</div><div class="line">(integer) 0</div><div class="line">#获取前10名(从高到低)</div><div class="line">redis&gt; zrevrange vote_activity 0 9</div><div class="line">1) &quot;Alice&quot;</div><div class="line">2) &quot;Bob&quot;</div><div class="line">#获取前10名及对应的分数(从高到低)</div><div class="line">redis&gt; zrevrange vote_activity 0 9 withscores</div><div class="line">1) &quot;Alice&quot;</div><div class="line">2) &quot;2&quot;</div><div class="line">3) &quot;Bob&quot;</div><div class="line">4) &quot;1&quot;</div><div class="line">#获取总参与选手数</div><div class="line">redis&gt; zcard vote_activity</div><div class="line">(integer) 2</div></pre></td></tr></table></figure></p>
<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>回到最开始的场景，大部分需求都已经得到满足，还剩下两个数据需要单独说一下。接口2中的总投票数没有直接的接口获得，一种方法是先用<a href="https://redis.io/commands/zrange" target="_blank" rel="external">ZRANGE</a>遍历所有的key，然后对score进行求和，另一种方法是对总票数单独用一个数据结构存储。接口3的距离上一名差的票数，先用<a href="https://redis.io/commands/zrevrank" target="_blank" rel="external">ZREVRANK</a>获取自己排名，然后用<a href="https://redis.io/commands/zrevrange" target="_blank" rel="external">ZREVRANGE</a>获取上一排名的分数，最后用自己的分数减去上一名的分数即可，代码示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_step</span><span class="params">(redis_key, member)</span>:</span></div><div class="line">    next_step = <span class="keyword">None</span></div><div class="line">    score = redis.zscore(redis_key, member)</div><div class="line">    rank = redis.zrevrank(redis_key, member)</div><div class="line">    <span class="keyword">if</span> rank &gt; <span class="number">0</span>:</div><div class="line">        next_member = redis.zrevrange(redis_key, rank - <span class="number">1</span>, rank - <span class="number">1</span>, withscores=<span class="keyword">True</span>)</div><div class="line">        next_step = next_member[<span class="number">0</span>][<span class="number">1</span>] - score</div><div class="line">    <span class="keyword">return</span> next_step</div></pre></td></tr></table></figure></p>
<p>另外如果两个key的score相同，排序逻辑是按照key的字母序排序。在有些情况下这个可能不满足实际要求，因此需要按实际情况重新设计key。比如如果要求同分数情况下按时间排序，那么key最好加上时间戳前缀。</p>
<h3 id="redis与数据库的同步"><a href="#redis与数据库的同步" class="headerlink" title="redis与数据库的同步"></a>redis与数据库的同步</h3><p>redis通常是作为缓存层加速查询的，如果数据没有做持久化则有概率会丢失数据。一个方案是用定时任务定时同步redis与数据库的数据，数据库里存储着原始数据，通过计算数据库的数据和redis做对比，可以修正由于redis不稳定导致的数据不一致。这里需要注意的是在同步过程时redis的数据有可能还在增长，因此最好先读redis的数据，然后记下时间，查询指定时间段里的数据库的数据，最后再用<a href="https://redis.io/commands/zincrby" target="_blank" rel="external">ZINCRBY</a>增量修正redis数据，而不是直接用<a href="https://redis.io/commands/zadd" target="_blank" rel="external">ZADD</a>覆盖redis数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis的有序集合是一个非常高效的数据结构，可以替代数据库里一些很难实现的操作。它的一个典型应用场景就是排行榜，通过ZRANK可以快速得到用户的排名，通过ZRANGE可以快速得到TOP N的用户列表，它们的复杂度都是O(log(N))，用来替代数据库查询可以大大提升性能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排行榜是业务开发中常见的一个场景，如何设计一个好的数据结构能够满足高效实时的查询，下面我们结合一个实际例子来讨论一下。&lt;/p&gt;
&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;选手报
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.secondplayer.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>使用redis实现分布式锁</title>
    <link href="http://www.secondplayer.top/2017/07/16/redis-distribution-lock/"/>
    <id>http://www.secondplayer.top/2017/07/16/redis-distribution-lock/</id>
    <published>2017-07-16T05:40:10.000Z</published>
    <updated>2017-09-04T15:34:29.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在类似秒杀这样的并发场景下，为了确保同一时刻只能允许一个用户访问资源，需要利用加锁的机制控制资源的访问权。如果服务只在单台机器上运行，可以简单地用一个内存变量进行控制。而在多台机器的系统上，则需要用分布式锁的机制进行并发控制。基于redis的一些特性，利用redis可以既方便又高效地模拟锁的实现。</p>
<h2 id="一个简单方案"><a href="#一个简单方案" class="headerlink" title="一个简单方案"></a>一个简单方案</h2><p>让我们先从一个简单的实现说起，这里用到了redis的两个命令，<a href="https://redis.io/commands/setnx" target="_blank" rel="external">SETNX</a>和<a href="https://redis.io/commands/expire" target="_blank" rel="external">EXPIRE</a>。如果lock_key不存在，那么就设置lock_key的值为1，并且设置过期时间；如果lock_key存在，说明已经有人在使用这把锁，访问失败。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(lock_key, expire_timeout=<span class="number">60</span>)</span>:</span></div><div class="line">    <span class="keyword">if</span> redis.setnx(lock_key, <span class="number">1</span>):</div><div class="line">        redis.expire(lock_key, expire_timeout)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<p>逻辑上看似乎没有问题，但是考虑一下异常情况：如果setnx设置成功，但expire由于某些原因（比如超时）操作失败，那么这把锁就永远存在了，也就是所谓的死锁，后面的人永远无法访问这个资源。</p>
<h2 id="利用时间戳取值的方案"><a href="#利用时间戳取值的方案" class="headerlink" title="利用时间戳取值的方案"></a>利用时间戳取值的方案</h2><p>为了解决死锁，我们可以利用setnx的value来做文章。上例中的我们设的value是1，其实并没有派上用场。因此可以考虑将value设为当前时间加上expire_timeout，当setnx设置失败后，我们去读lock_key的value，并且和当前时间作比对，如果当前时间大于value，那么资源理当被释放。代码示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(lock_key, expire_timeout=<span class="number">60</span>)</span>:</span></div><div class="line">    expire_time = int(time.time()) + expire_timeout</div><div class="line">    <span class="keyword">if</span> redis.setnx(lock_key, expire_time):</div><div class="line">        redis.expire(lock_key, expire_timeout)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    redis_value = redis.get(lock_key)</div><div class="line">    <span class="keyword">if</span> redis_value <span class="keyword">and</span> int(time.time()) &gt; int(redis_value):</div><div class="line">        redis.delete(lock_key)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<p>然而仔细推敲下这段代码仍然能发现一些问题。第一，这个方案依赖时间，如果在分布式系统中的时间没有同步，则会对方案产生一定偏差。第二，假设C1和C2都没拿到锁，它们都去读value并对比时间，在竞态条件(race condition)下可能产生如下的时序：C1删除lock_key，C1获得锁，C2删除lock_key，C2获得锁。这样C1和C2同时拿到了锁，显然是不对的。</p>
<h2 id="改进后的方案"><a href="#改进后的方案" class="headerlink" title="改进后的方案"></a>改进后的方案</h2><p>幸运的是，redis里还有一个指令可以帮助我们解决这个问题。<a href="https://redis.io/commands/getset" target="_blank" rel="external">GETSET</a>指令在set新值的同时会返回老的值，这样的话我们可以检查返回的值，如果该值和之前读出来的值相同，那么这次操作有效，反之则无效。代码示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(lock_key, expire_timeout=<span class="number">60</span>)</span>:</span></div><div class="line">    expire_time = int(time.time()) + expire_timeout</div><div class="line">    <span class="keyword">if</span> redis.setnx(lock_key, expire_time):</div><div class="line">        redis.expire(lock_key, expire_timeout)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    redis_value = redis.get(lock_key)</div><div class="line">    <span class="keyword">if</span> redis_value <span class="keyword">and</span> int(time.time()) &gt; int(redis_value):</div><div class="line">        expire_time = int(time.time()) + expire_timeout</div><div class="line">        old_value = redis.getset(lock_key, expire_time)</div><div class="line">        <span class="keyword">if</span> int(old_value) == int(redis_value):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<p>这个方案基本可以满足要求，除了有一个小瑕疵，由于getset会去修改value，在竞态条件下可能会被修改多次导致timeout有细微的误差，但这个对结果影响不大。</p>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>以上方案实现起来略显繁琐，但从redis 2.6.12版本开始有一个更为简便的方法。我们可以使用<a href="https://redis.io/commands/set" target="_blank" rel="external">SET</a>指令的扩展 <strong> SET key value [EX seconds] [PX milliseconds] [NX|XX] </strong>，这个指令相当于对SETNX和EXPIRES进行了合并，因而我们的算法可以简化为如下一行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(lock_key, expire_timeout=<span class="number">60</span>)</span>:</span></div><div class="line">    ret = redis.set(lock_key, int(time.time()), nx=<span class="keyword">True</span>, ex=expire_timeout):</div><div class="line">    <span class="keyword">return</span> ret</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在redis 2.6.12版本之后我们可以用一个简单的SET命令实现分布式锁，而在此版本之前则需要将SETNX和GETSET配合使用一个较为繁琐的方案。简化后的方案对于开发者来说当然是好事，但通过学习这一演变过程我们会对问题有更深刻的印象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在类似秒杀这样的并发场景下，为了确保同一时刻只能允许一个用户访问资源，需要利用加锁的机制控制资源的访问权。如果服务只在单台机器上运行，可以简
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.secondplayer.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo搭建个人静态博客</title>
    <link href="http://www.secondplayer.top/2016/06/12/hexo-blog-setup/"/>
    <id>http://www.secondplayer.top/2016/06/12/hexo-blog-setup/</id>
    <published>2016-06-12T06:42:23.000Z</published>
    <updated>2017-09-04T15:34:09.500Z</updated>
    
    <content type="html"><![CDATA[<p>最近有时间折腾了一下建一个个人博客，在对比了几家之后，最终决定用<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>作为框架，<a href="https://github.com/" target="_blank" rel="external">GitHub</a>作为部署平台搭建博客。VPS选用的是<a href="https://aws.amazon.com/" target="_blank" rel="external">AWS</a>，新用户可以免费使用1年的EC2，足够用来体验了。</p>
<h2 id="申请VPS"><a href="#申请VPS" class="headerlink" title="申请VPS"></a>申请VPS</h2><p>VPS指的是虚拟服务器，国内推荐用<a href="https://www.aliyun.com/" target="_blank" rel="external">阿里云</a>，国外推荐用<a href="https://www.linode.com/" target="_blank" rel="external">Linode</a>, <a href="https://www.digitalocean.com/" target="_blank" rel="external">Digital Ocean</a>, <a href="https://aws.amazon.com/" target="_blank" rel="external">AWS</a>。我选择的是AWS，主要有几个原因，一是因为新用户可以试用免费1年，二是因为公司用的就是AWS，对其各项操作比较熟悉，最后一个原因是选择一个国外服务器可以自己搭建ShadowSocks<a href="https://segmentfault.com/a/1190000003101075" target="_blank" rel="external">科学上网</a>。</p>
<h2 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h2><p>域名申请服务商，国内有<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">万网</a>，<a href="http://www.cndns.com/" target="_blank" rel="external">美橙</a>，国外有<a href="https://www.godaddy.com/" target="_blank" rel="external">GoDaddy</a>, <a href="https://www.namecheap.com/" target="_blank" rel="external">NameCheap</a>。我选择的是NameCheap，主要因为价格因素。你要问国内的那些更便宜为啥不选？呵呵国内的情况你懂的。</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>DNS解析推荐<a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPOD</a>，业界良心，服务免费且强大。域名绑定前记得先到NameCheap控制台设置DNS解析到DNSPOD提供的两个免费DNS解析服务器，具体参考<a href="https://support.dnspod.cn/Kb/showarticle/?qtype=%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&amp;tsid=47" target="_blank" rel="external">这里</a>。</p>
<h2 id="Hexo安装及配置"><a href="#Hexo安装及配置" class="headerlink" title="Hexo安装及配置"></a>Hexo安装及配置</h2><p>前面把主机和域名搞定了，现在开始在主机上搭建博客了。提到博客，一般都会选用经典的<a href="https://www.wordpress.com/" target="_blank" rel="external">WordPress</a>搭建。不过现在越来越多的个人博客都采用静态博客框架，典型的如<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>， <a href="https://jekyllrb.com/" target="_blank" rel="external">Jekyll</a>， <a href="https://github.com/octopress/octopress" target="_blank" rel="external">Octopress</a>。从流行度和技术栈的角度来看，我倾向于选择Hexo。<br><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>是一个用Node.js搭建的博客框架，简单强大易上手。静态文件用<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown</a>编写，Hexo会根据静态文件自动生成网页。</p>
<h3 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h3><ul>
<li>安装<a href="https://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git</div></pre></td></tr></table></figure>
<ul>
<li>安装<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a></li>
</ul>
<p>通常用<a href="https://www.npmjs.com/package/nvm" target="_blank" rel="external">nvm</a>(Node.js Version Manager)安装Node环境<br>安装必要环境<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install build-essential libssl-dev</div></pre></td></tr></table></figure></p>
<p>下载nvm<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</div></pre></td></tr></table></figure></p>
<p>查看可用版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nvm ls-remote</div></pre></td></tr></table></figure></p>
<p>选取最新版本，这里我们安装v4.4.5，并将其设为默认<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ nvm install 4.4.5</div><div class="line">$ nvm <span class="built_in">alias</span> default 4.4.5</div><div class="line">$ nvm use default</div></pre></td></tr></table></figure></p>
<ul>
<li>安装<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a></li>
</ul>
<p>我们通过npm分别安装hexo客户端和服务端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div><div class="line">$ npm install -g hexo-server</div></pre></td></tr></table></figure>
<h3 id="生成文章"><a href="#生成文章" class="headerlink" title="生成文章"></a>生成文章</h3><ul>
<li>初始化hexo环境</li>
</ul>
<p>我们把hexo_blog作为博客目录名，首先初始化hexo</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init ~/hexo_blog</div><div class="line">$ <span class="built_in">cd</span> ~/hexo_blog</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<ul>
<li>修改配置文件_config.yml</li>
</ul>
<p>配置Site, URL, Directory, Writing等基本信息，详细参考这篇<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">配置文档</a><br>这里建议设置default_layout为draft，这样默认生成文章在Draft里，确认后再发布到Public。</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><ul>
<li>新建文章，以名称first_post为例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new first-post</div></pre></td></tr></table></figure>
<ul>
<li>编辑文章，文章都存放在source目录下</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim ~/hexo_blog/<span class="built_in">source</span>/_drafts/first-post.md</div></pre></td></tr></table></figure>
<ul>
<li>发布文章，这将会把文章从draft移到post目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo publish first-post</div></pre></td></tr></table></figure>
<h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><ul>
<li>启动服务器，默认起在4000端口，成功后访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 预览效果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h3 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h3><p>我们需要选择一个静态文件的托管平台，首选<a href="https://github.com/" target="_blank" rel="external">GitHub</a>，国内可以考虑<a href="https://coding.net/" target="_blank" rel="external">Coding</a>（最近收购了<a href="http://gitcafe.com/" target="_blank" rel="external">GitCafe</a>）。</p>
<ul>
<li>创建GitHub Repository</li>
</ul>
<p>参考这个<a href="https://help.github.com/articles/creating-a-new-repository/" target="_blank" rel="external">步骤</a>，创建一个名为hexo_static的repo，注意设置为Public</p>
<ul>
<li>修改配置文件_config.yml，注意替换<em>$username</em></li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span> </div><div class="line"><span class="attr">  type:</span> <span class="string">git</span> </div><div class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/$username/hexo_static.git</span></div><div class="line"><span class="attr">  branch:</span> <span class="string">master</span></div></pre></td></tr></table></figure>
<ul>
<li>安装hexo git插件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<ul>
<li>部署</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>按照提示输入用户名和密码，一切步骤完成后，所有文件都已生成并提交到Git上了</p>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>整个自动化的思路是：运行该脚本，生成博客静态文件，通过hexo deploy实现自动提交到Git，然后通过本地更新代码，对关联的空分支进行git push操作，触发post-receive钩子，从而将静态文件同步到/var/www/hexo目录，而该目录正是Nginx将80端口转发到本地的路径。</p>
<ul>
<li>初始化空仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init --bare ~/hexo_bare</div></pre></td></tr></table></figure>
<ul>
<li>创建git hooks</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim ~/hexo_bare/hooks/post-receive</div></pre></td></tr></table></figure>
<p>这里我们用到了post-receive这个钩子，当一个本地仓库执行git push后会触发。post-receive具体内容为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">git --work-tree=/var/www/hexo --git-dir=/home/<span class="variable">$USER</span>/hexo_bare checkout -f</div></pre></td></tr></table></figure>
<ul>
<li>将空仓库关联到主仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/<span class="variable">$username</span>/hexo_static.git ~/hexo_static </div><div class="line">$ <span class="built_in">cd</span> ~/hexo_static</div><div class="line">$ git remote add live ~/hexo_bare</div></pre></td></tr></table></figure>
<ul>
<li>创建自动化脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim ~/hexo_blog/hexo_git_deploy.sh</div></pre></td></tr></table></figure>
<p>脚本内容为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line">hexo clean</div><div class="line">hexo generate </div><div class="line">hexo deploy</div><div class="line"></div><div class="line">( <span class="built_in">cd</span> ~/hexo_static ; git pull ; git push live master)</div></pre></td></tr></table></figure>
<ul>
<li>Nginx配置</li>
</ul>
<p>创建/var/www/hexo目录，稍后会将Nginx的请求映射到该目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir -p /var/www/hexo</div><div class="line">$ sudo chown -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /var/www/hexo</div><div class="line">$ sudo chmod -R 755 /var/www/hexo</div></pre></td></tr></table></figure>
<p>编辑/etc/nginx/sites-available/default<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo vim /etc/nginx/sites-available/default</div></pre></td></tr></table></figure></p>
<p>配置Nginx将80端口的请求映射到/var/www/hexo目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server &#123; </div><div class="line">    listen 80 default_server; </div><div class="line">    listen [::]:80 default_server ipv6only=on; </div><div class="line">    root /var/www/hexo; </div><div class="line">    index index.html index.htm;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>重启Nginx</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service nginx restart</div></pre></td></tr></table></figure>
<h3 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h3><p>至此，我们可以总结下今后发布文章或更新博客的流程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo new my-post</div><div class="line">$ vim ~/hexo_blog/<span class="built_in">source</span>/_draft/my-post.md</div><div class="line">$ hexo publish my-post</div><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>接着运行hexo server，然后在<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 上预览效果，如果不满意则继续修改my-post.md（此时在_post目录下），重新生成文件（hexo generate），再预览直到可以发布为止</p>
<p>而最终对外发布，我们只需要敲下一行命令就完成了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ~/hexo_blog/hexo_git_deploy.sh</div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>主题</li>
</ul>
<p>默认hexo的主题是<a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="external">landscape</a>，如果你想与众不同的话，可以用下别的主题或者自定义主题。官方收录的请点击<a href="https://hexo.io/themes/" target="_blank" rel="external">这里</a>，我选择的是<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="external">indigo</a>，主要看中的是他的Material Design风格</p>
<ul>
<li>评论</li>
</ul>
<p>常见的评论系统有<a href="https://disqus.com/" target="_blank" rel="external">Disqus</a>，<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>，<a href="http://www.uyan.cc/" target="_blank" rel="external">友言</a>等，我选择的是多说。接入非常简单，去网站上注册个账号，然后将示例代码插到网页中即可</p>
<ul>
<li>统计</li>
</ul>
<p>流量统计选择<a href="http://tongji.cnzz.com/" target="_blank" rel="external">cnzz</a>(现已被整合进<a href="https://www.umeng.com/" target="_blank" rel="external">Umeng+</a>)</p>
<ul>
<li>监控</li>
</ul>
<p>可以接入<a href="http://www.jiankongbao.com/" target="_blank" rel="external">监控宝</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://hexo.io/docs/" target="_blank" rel="external">Hexo Documentation</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-blog-with-hexo-on-ubuntu-14-04" target="_blank" rel="external">How to Create a Blog with Hexo On Ubuntu 14.04</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有时间折腾了一下建一个个人博客，在对比了几家之后，最终决定用&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;作为框架，&lt;a href=&quot;https://github.com/&quot; targ
    
    </summary>
    
    
      <category term="Hexo" scheme="http://www.secondplayer.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.secondplayer.top/2016/06/11/hello-world/"/>
    <id>http://www.secondplayer.top/2016/06/11/hello-world/</id>
    <published>2016-06-10T16:00:00.000Z</published>
    <updated>2017-09-04T15:37:50.579Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
